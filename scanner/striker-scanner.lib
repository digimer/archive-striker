#!/usr/bin/perl

use strict;
use warnings;

# Set static variables.
my $THIS_FILE = "striker-scanner.lib";

# This initializes a call; reads variables, etc.
sub initialize
{
	my ($caller) = @_;
	
	# Set default configuration variable values
	my ($conf) = initialize_conf($caller);

	# First up, read in the default strings file.
	read_strings($conf, $conf->{path}{words_common});
	read_strings($conf, $conf->{path}{words_file});

	# Read in the configuration file. If the file doesn't exist, initial 
	# setup will be triggered.
	read_configuration_file($conf, $caller);
	
	return($conf);
}

# Set default configuration variable values
sub initialize_conf
{
	my ($caller) = @_;
	
	my $conf = {
		path				=>	{
			config_file			=>	"/etc/an/striker.conf",
			log_file			=>	"/var/log/striker-scanner.log",
			tput				=>	"/usr/bin/tput",
			words_common			=>	"./common.xml",
			words_file			=>	"./striker-scanner.xml",
		},
		# These are setuid root C-wrapper scripts that allow apache to
		# make system calls as root.
		setuid				=>	{
			'call_gather-system-info'	=>	"./call_gather-system-info",
		},
		sys				=>	{
			error_limit			=>	1000,
			language			=>	"en_CA",
			html_lang			=>	"en",
			skin				=>	"alteeve",
			version				=>	"0.0.1",
			log_level			=>	3,
			use_24h				=>	1,			# Set to 0 for am/pm time, 1 for 24h time
			date_seperator			=>	"-",			# Should put these in the strings.xml file
			time_seperator			=>	":",
			log_language			=>	"en_CA",
			system_timezone			=>	"America/Toronto",
			output				=>	"text",
		},
		db				=>	{
			name				=>	"striker",
			user				=>	"alteeve",
			password			=>	"secret",
		},
		# Config values needed to managing strings
		strings				=>	{
			encoding			=>	"",
			force_utf8			=>	0,
			xml_version			=>	"",
		},
		# The actual strings
		string				=>	{},
	};
	
	return($conf);
}

# If the configuration file does not yet exist, it will trigger the initial
# installation of the system.
sub initial_configuration
{
	my ($conf, $caller) = @_;
	
	# Tell the user we are starting.
	print "\n", get_wrapped_string($conf, {key => 'install_0000', variables => {config_file => $conf->{path}{config_file}}}), "\n\n";
	
	my $yes_answer  = get_string($conf, {key => 'answer_0000'});
	my $yes_short   = get_string($conf, {key => 'answer_0001'});
	my $no_answer   = get_string($conf, {key => 'answer_0002'});
	my $no_short    = get_string($conf, {key => 'answer_0003'});
	my $language    = $conf->{sys}{language};
	my $db_type     = "Pg";
	my $db_server   = "localhost";
	my $db_port     = 5432;
	my $db_name     = "striker-scanner";
	my $db_user     = "alteeve";
	my $db_password = "";
	while (1)
	{
		# As the database type (disabled for now)
		#print get_wrapped_string($conf, {key => 'install_0003', variables => { answer => "$db_type_answer"}}), "\n";
		#my $db_type_answer = <STDIN>;
		#chomp($db_type_answer);
		#$db_type = $db_type_answer if $db_type_answer;
		
		# Ask for the database server hostname or IP
		print get_wrapped_string($conf, {key => 'install_0004', variables => { answer => "$db_server"}});
		my $db_server_answer = <STDIN>;
		chomp($db_server_answer);
		$db_server = $db_server_answer if $db_server_answer;
		print " - $db_server\n";
		
		# Ask for the database TCP port
		print get_wrapped_string($conf, {key => 'install_0005', variables => { answer => "$db_port"}});
		my $db_port_answer = <STDIN>;
		chomp($db_port_answer);
		$db_port = $db_port_answer if $db_port_answer;
		print " - $db_port\n";
		
		# Ask for the database name.
		print get_wrapped_string($conf, {key => 'install_0006', variables => { answer => "$db_name"}});
		my $db_name_answer = <STDIN>;
		chomp($db_name_answer);
		$db_name = $db_name_answer if $db_name_answer;
		print " - $db_name\n";
		
		# Ask for the database user.
		print get_wrapped_string($conf, {key => 'install_0007', variables => { answer => "$db_user"}});
		my $db_user_answer = <STDIN>;
		chomp($db_user_answer);
		$db_user = $db_user_answer if $db_user_answer;
		print " - $db_user\n";
		
		# Ask for the database password.
		print get_wrapped_string($conf, {key => 'install_0008'});
		ReadMode('noecho');
		my $db_password_answer = <STDIN>;
		ReadMode('restore');
		chomp($db_password_answer);
		$db_password = $db_password_answer if $db_password_answer;
		print "\n - ****\n";
		
		print "\n", get_wrapped_string($conf, {key => 'install_0001', variables => {
			'db::type'	=>	"$db_type",
			'db::server'	=>	"$db_server",
			'db::port'	=>	"$db_port",
			'db::name'	=>	"$db_name",
			'db::user'	=>	"$db_user",
			'db::password'	=>	"****",
		}});
		my $save = <STDIN>;
		chomp($save);
		print "save: [$save], yes_answer: [$yes_answer], yes_short: [$yes_short]\n";
		if ((lc($save) eq lc($yes_answer)) or (lc($save) eq lc($yes_short)))
		{
			print "Saved\n";
			last;
		}
		else
		{
			print "Restarting.\n\n";
		}
	}
	
	#write_config($conf);
	
	return(0);
}

# Read in the configuration file. If the file doesn't exist, initial setup will
# be triggered.
sub read_configuration_file
{
	my ($conf, $caller) = @_;
	
	if (not -e $conf->{path}{config_file})
	{
		# Must be a new install.
		initial_configuration($conf, $caller);
	}
	else
	{
		my $read  = IO::Handle->new();
		my $shell_call = "$conf->{file}{config}";
		# This is causing a loop... can't call 'error' this early.
		open ($read, $shell_call) or hard_die($conf, $THIS_FILE, __LINE__, 1, "Failed to read: [$shell_call]. The error was: $!\n");
		binmode $read, ":utf8:";
		while (<$read>)
		{
			chomp;
			my $line = $_;
			
			# Protect '#!....!#' substitution variables.
			$line =~ s/#!/_!\|/;
			$line =~ s/!#/\|!_/;
			
			# Now remove anything after a hash
			$line =~ s/#(.*)//;
			
			# And restore the substitution variables.
			$line =~ s/_!\|/#!/;
			$line =~ s/\|!_/!#/;
			
			# Skip lines without an = sign... no idea why they'd
			# be here.
			next if ($line !~ /=/);
			
			# Split on the first = sign
			my ($variable, $value) = split/=/, $line, 2;
			
			# Crop leading and trailing spaces from the variables
			# and values.
			$variable =~ s/^\s+//;
			$variable =~ s/\s+$//;
			$value    =~ s/^\s+//;
			$value    =~ s/\s+$//;

			# Check if the variable needs to be split on '::' and
			# stored in multi-dimensional hashes.
			if ( $variable =~ /::/ )
			{
				_make_hash_reference($conf, $variable, $value);
			}
			else
			{
				# Simple variable, I can just store it's value.
				$conf->{$variable} = $value;
			}
		}
		$read->close();
	}
	
	return(0);
}

# This writes out an initial configuration file.
sub write_config
{
	my ($conf) = @_;
	
	
	
	return(0);
}

1;
