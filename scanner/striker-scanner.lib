#!/usr/bin/perl

use strict;
use warnings;

# Set static variables.
my $THIS_FILE = "striker-scanner.lib";

# This initializes a call; reads variables, etc.
sub initialize
{
	my ($caller) = @_;
	
	# Set default configuration variable values
	my ($conf) = initialize_conf($caller);

	# First up, read in the default strings file.
	read_strings($conf, $conf->{path}{words_common});
	read_strings($conf, $conf->{path}{words_file});

	# Read in the configuration file. If the file doesn't exist, initial 
	# setup will be triggered.
	read_configuration_file($conf, $caller);
	
	return($conf);
}

# Set default configuration variable values
sub initialize_conf
{
	my ($caller) = @_;
	
	my $conf = {
		path				=>	{
			config_file			=>	"/etc/an/striker.conf",
			log_file			=>	"/var/log/striker-scanner.log",
			words_common			=>	"./common.xml",
			words_file			=>	"./striker-scanner.xml",
		},
		# These are setuid root C-wrapper scripts that allow apache to
		# make system calls as root.
		setuid				=>	{
			'call_gather-system-info'	=>	"./call_gather-system-info",
		},
		sys				=>	{
			error_limit			=>	1000,
			language			=>	"en_CA",
			html_lang			=>	"en",
			skin				=>	"alteeve",
			version				=>	"0.0.1",
			log_level			=>	3,
			use_24h				=>	1,			# Set to 0 for am/pm time, 1 for 24h time
			date_seperator			=>	"-",			# Should put these in the strings.xml file
			time_seperator			=>	":",
			log_language			=>	"en_CA",
			system_timezone			=>	"America/Toronto",
		},
		db				=>	{
			name				=>	"striker",
			user				=>	"alteeve",
			password			=>	"secret",
		},
		# Config values needed to managing strings
		strings				=>	{
			encoding			=>	"",
			force_utf8			=>	0,
			xml_version			=>	"",
		},
		# The actual strings
		string				=>	{},
	};
	
	return($conf);
}

# If the configuration file does not yet exist, it will trigger the initial
# installation of the system.
sub initial_configuration
{
	my ($conf, $caller) = @_;
	
	print "\n", get_string($conf, {key => 'install_0000', variables => {config_file => $conf->{path}{config_file}}}), "\n\n";
	
	return(0);
}

# Read in the configuration file. If the file doesn't exist, initial setup will
# be triggered.
sub read_configuration_file
{
	my ($conf, $caller) = @_;
	
	if (not -e $conf->{path}{config_file})
	{
		# Must be a new install.
		initial_configuration($conf, $caller);
	}
	else
	{
		my $read  = IO::Handle->new();
		my $shell_call = "$conf->{file}{config}";
		# This is causing a loop... can't call 'error' this early.
		open ($read, $shell_call) or hard_die($conf, $THIS_FILE, __LINE__, 1, "Failed to read: [$shell_call]. The error was: $!\n");
		binmode $read, ":utf8:";
		while (<$read>)
		{
			chomp;
			my $line = $_;
			
			# Protect '#!....!#' substitution variables.
			$line =~ s/#!/_!\|/;
			$line =~ s/!#/\|!_/;
			
			# Now remove anything after a hash
			$line =~ s/#(.*)//;
			
			# And restore the substitution variables.
			$line =~ s/_!\|/#!/;
			$line =~ s/\|!_/!#/;
			
			# Skip lines without an = sign... no idea why they'd
			# be here.
			next if ($line !~ /=/);
			
			# Split on the first = sign
			my ($variable, $value) = split/=/, $line, 2;
			
			# Crop leading and trailing spaces from the variables
			# and values.
			$variable =~ s/^\s+//;
			$variable =~ s/\s+$//;
			$value    =~ s/^\s+//;
			$value    =~ s/\s+$//;

			# Check if the variable needs to be split on '::' and
			# stored in multi-dimensional hashes.
			if ( $variable =~ /::/ )
			{
				_make_hash_reference($conf, $variable, $value);
			}
			else
			{
				# Simple variable, I can just store it's value.
				$conf->{$variable} = $value;
			}
		}
		$read->close();
	}
	
	return(0);
}

1;
