#!/usr/bin/perl
# 
# Common functions for 'striker'.
#

use strict;
use warnings;

# Set static variables.
my $THIS_FILE = "striker.lib";


# This initializes a call; reads variables, etc.
sub initialize
{
	my ($caller) = @_;
	
	# Set default configuration variable values
	my ($conf) = initialize_conf($caller);
	
	# First thing first, initialize the web session.
	initialize_http($conf);

	# First up, read in the default strings file.
	read_strings($conf, $conf->{path}{words_common});
	read_strings($conf, $conf->{path}{words_file});

	# Read in the configuration file. If the file doesn't exist, initial 
	# setup will be triggered.
	read_configuration_file($conf, $caller);
	
	return($conf);
}

# Set default configuration variable values
sub initialize_conf
{
	my ($caller) = @_;
	
	my $conf = {
		path				=>	{
			config_file			=>	"/etc/an/striker.conf",
			log_file			=>	"../logs/striker.log",
			skins				=>	"../html/skins/",
			words_common			=>	"./common.xml",
			words_file			=>	"./strings.xml",
		},
		# These are setuid root C-wrapper scripts that allow apache to
		# make system calls as root.
		setuid				=>	{
			'call_gather-system-info'	=>	"/var/www/tools/call_gather-system-info",
		},
		sys				=>	{
			error_limit			=>	1000,
			language			=>	"en_CA",
			html_lang			=>	"en",
			skin				=>	"alteeve",
			version				=>	"0.0.1",
			log_level			=>	3,
			use_24h				=>	1,			# Set to 0 for am/pm time, 1 for 24h time
			date_seperator			=>	"-",			# Should put these in the strings.xml file
			time_seperator			=>	":",
			log_language			=>	"en_CA",
			system_timezone			=>	"America/Toronto",
		},
		db				=>	{
			name				=>	"an-${caller}",
			user				=>	"alteeve",
			password			=>	"secret",
		},
		url				=>	{
			skins				=>	"/skins/",
			cgi				=>	"/cgi-bin/",
		},
		# Config values needed to managing strings
		strings				=>	{
			encoding			=>	"",
			force_utf8			=>	0,
			xml_version			=>	"",
		},
		# The actual strings
		string				=>	{},
	};
	
	return($conf);
}

# Read in the configuration file. If the file doesn't exist, initial setup will
# be triggered.
sub read_configuration_file
{
	my ($conf, $caller) = @_;
	
	if (not -e $conf->{path}{config_file})
	{
		# The use might be saving the new values. Read the CGI 
		# variables now and check.
		record($conf, {line => __LINE__, file => $THIS_FILE, level => 2, message => "reading vars\n"});
		get_cgi_vars($conf, [
			"config_name",
			"defroute",
			"interfaces",
			"language",
			"org_name",
			"save",
			"striker_db_name",
			"striker_db_password",
			"striker_db_user",
			"striker_user",
			"striker_password",
			"summary",
			"system_name",
			"system_timezone",
		]);
		
		record($conf, {line => __LINE__, file => $THIS_FILE, level => 4, message => "cgi::summary: [$conf->{cgi}{summary}]\n"});
		if ($conf->{cgi}{summary})
		{
			summarize_initial_configuration($conf, $caller);
		}
		elsif ($conf->{cgi}{save})
		{
			write_config($conf, $caller);
		}
		else
		{
			# Must be a new install.
			initial_configuration($conf, $caller);
		}
	}
	else
	{
		my $read  = IO::Handle->new();
		my $shell_call = "$conf->{file}{config}";
		# This is causing a loop... can't call 'error' this early.
		open ($read, $shell_call) or hard_die($conf, $THIS_FILE, __LINE__, 1, "Failed to read: [$shell_call]. The error was: $!\n");
		binmode $read, ":utf8:";
		while (<$read>)
		{
			chomp;
			my $line = $_;
			
			# Protect '#!....!#' substitution variables.
			$line =~ s/#!/_!\|/;
			$line =~ s/!#/\|!_/;
			
			# Now remove anything after a hash
			$line =~ s/#(.*)//;
			
			# And restore the substitution variables.
			$line =~ s/_!\|/#!/;
			$line =~ s/\|!_/!#/;
			
			# Skip lines without an = sign... no idea why they'd
			# be here.
			next if ($line !~ /=/);
			
			# Split on the first = sign
			my ($variable, $value) = split/=/, $line, 2;
			
			# Crop leading and trailing spaces from the variables
			# and values.
			$variable =~ s/^\s+//;
			$variable =~ s/\s+$//;
			$value    =~ s/^\s+//;
			$value    =~ s/\s+$//;

			# Check if the variable needs to be split on '::' and
			# stored in multi-dimensional hashes.
			if ( $variable =~ /::/ )
			{
				_make_hash_reference($conf, $variable, $value);
			}
			else
			{
				# Simple variable, I can just store it's value.
				$conf->{$variable} = $value;
			}
		}
		$read->close();
	}
	
	return(0);
}

# Summarize the user's form data and ask them to confirm.
sub summarize_initial_configuration
{
	my ($conf, $caller) = @_;
	
	record($conf, {line => __LINE__, file => $THIS_FILE, level => 4, message => "caller: [$caller]\n"});
	summarize_initial_striker_configuration($conf);
	
	return(0);
}

# If the configuration file does not yet exist, it will trigger the initial
# installation of the system.
sub initial_configuration
{
	my ($conf, $caller) = @_;
	
	# Read any install-specific CGI variables.
	get_cgi_vars($conf, [
		"config_name",
		"language",
		"system_name",
		"interfaces",
		"defroute",
		"striker_user",
		"striker_password",
		"striker_db_name",
		"striker_db_user",
		"striker_db_password",
		"org_name",
		"summary",
	]);
	
	initial_striker_configuration($conf);
	
	return(0);
}

# This summarizes the user's striker configuration for data and asks them to
# confirm before proceeding.
sub summarize_initial_striker_configuration
{
	my ($conf) = @_;
	record($conf, {line => __LINE__, file => $THIS_FILE, level => 4, message => "-> summarize_initial_striker_configuration()\n"});
	
	# Print the template.
	my $language_options = get_languages($conf);
	my $select_language = build_html_select($conf, {
		select_name	=>	"language",
		select_id	=>	"language",
		selected_option	=>	$conf->{cgi}{language},
		blank_option	=>	0,
		options		=>	$language_options,
		attributes	=>	"onselect='null()'",
	});
	record($conf, {line => __LINE__, file => $THIS_FILE, level => 4, message => "select_language: [$select_language]\n"});
	
	my ($nic_replace) = gather_network_interface_info($conf, "summarize");
	my $variables = {};
	my $replace   = {
		language_select	=>	$select_language,
		nic_form	=>	$nic_replace,
	};
	print template($conf, "install", "summarize", $variables, $replace);
	
	return(0);
}

# This is run when the host system is determined to be a 'striker' dashboard 
# and has not been configured. When done, it will create the configuration 
# file. The existance of that file prevents this from running again.
sub initial_striker_configuration
{
	my ($conf) = @_;
	
	# Build the language select input.
	my $language_options = get_languages($conf);
	my $select_language = build_html_select($conf, {
		select_name	=>	"language",
		select_id	=>	"language",
		selected_option	=>	$conf->{cgi}{language},
		blank_option	=>	0,
		options		=>	$language_options,
		attributes	=>	"onselect='null()'",
	});
	
	if (not $conf->{cgi}{system_timezone})
	{
		$conf->{cgi}{system_timezone} = $conf->{sys}{system_timezone};
	}
	my $system_timezone = build_timezone_select($conf, {
		select_name	=>	"system_timezone",
		select_id	=>	"system_timezone",
		selected_option	=>	$conf->{cgi}{system_timezone},
		blank_option	=>	0,
		attributes	=>	"",
	});
	
	# Call the 'gather-system-info' tool
	call_gather_system_info($conf);
	
	# This collects the network interface information
	my ($nic_replace) = gather_network_interface_info($conf, "initial");
	
	# If there is no hostname in {cgi} yet, set it to the hostname read by
	# gather-system-ingo.
	#print "<pre>cgi::system_name: [$conf->{cgi}{system_name}], sys::hostname: [$conf->{sys}{hostname}]</pre>\n";
	if ((not $conf->{cgi}{system_name}) && ($conf->{sys}{hostname}))
	{
		$conf->{cgi}{system_name} = $conf->{sys}{hostname};
	}
	
	# Print the template.
	my $variables = {};
	my $replace   = {
		language_select	=>	$select_language,
		nic_form	=>	$nic_replace,
		system_timezone	=>	$system_timezone,
	};
	print template($conf, "install", "welcome", $variables, $replace);
	
	exit(0);
}

1;
