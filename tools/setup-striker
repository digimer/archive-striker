#!/usr/bin/perl

use strict;
use warnings;
use Term::ReadKey;

my $THIS_FILE =  $0;
   $THIS_FILE =~ s/^.*\///;

my $conf = {
	answers		=>	{
		language	=>	"",
	},
	executable		=>	{
		ethtool		=>	"/usr/sbin/ethtool",
		ip		=>	"/usr/sbin/ip",
		logger		=>	"/usr/bin/logger",
		tput		=>	"/usr/bin/tput",
		yum		=>	"/usr/bin/yum",
	},
	language	=>	{
		# Copy this to other languages.
		en_CA		=>	{
			name		=>	"English (Canada)",
			# Variable substitution in strings is limited to 
			# '#!variable!...!#' only!
			string		=>	{
				# Answers to previous questions.
				answer_0001	=>	"* Language: [#!variable!language!#]",
				
				# Errors
				error_0001	=>	"I am sorry, but you have to run this as the 'root' user (real or effective).",
				error_0002	=>	"Failed to call: [#!variable!shell_call!#]. The error was: #!variable!error!#",
				error_0003	=>	"Failed to open: [#!variable!file!#] for writing. The error was: #!variable!error!#",
				error_0004	=>	"Failed to open: [#!variable!file!#] for reading. The error was: #!variable!error!#",
				
				# Log messages
				log_0001	=>	"Starting striker setup",
				log_0002	=>	"Opening: [#!variable!file!#] for writing.",
				log_0003	=>	"Opening: [#!variable!file!#] for reading.",
				log_0004	=>	"Calling: [#!variable!shell_call!#].",
				
				# Normal strings
				message_0001	=>	"-=[ Striker Setup ]=-",
				message_0002	=>	"Please choose a language:",
				
				# Prefixes
				prefix_0001	=>	"[ Error ]",
				prefix_0002	=>	"Error code is #!variable!error!#",
			},
		},
		en_GB		=>	{
			use_language	=>	"en_CA",
		},
		en_US		=>	{
			use_language	=>	"en_CA",
		},
		jp		=>	{
			name		=>	"日本語",
			# Variable substitution in strings is limited to 
			# '#!variable!...!#' only!
			string		=>	{
				# Answers to previous questions.
				answer_0001	=>	"※ 言語: [#!variable!language!#]",
				
				# Errors
				error_0001	=>	"申し訳ございませんが、このプログラムはrootユーザーとして実行する必要があります。",
				error_0002	=>	"プログラムは、[#!variable!shell_call!#]を呼び出そうとしましたが、失敗しました。エラーが[#!variable!error!#]だった。",
				error_0003	=>	"プログラムは、書き込みのために、[#!variable!file!#]を開くことができませんでした。エラーが[#!variable!error!#]だった。",
				error_0004	=>	"ファイル[#!variable!file!#]を読み取ることができませんでした。エラーが[#!variable!error!#]だった。",
				
				# Log messages
				log_0001	=>	"Strikerのセットアップを開始しています",
				log_0002	=>	"書き込み用にファイル[#!variable!file!#]を開く。",
				log_0003	=>	"読み取り用にファイル[#!variable!file!#]を開く。",
				log_0004	=>	"[#!variable!shell_call!#]プログラムを呼び出す。",
				
				# Normal strings
				message_0001	=>	"-=[ Strikerのセットアップ ]=-",
				message_0002	=>	"言語を選択してください：",
				
				# Prefixes
				prefix_0001	=>	"[ エラー ]",
				prefix_0002	=>	"エラーコードは[#!variable!error!#]である",
			},
		},
	},
	path		=>	{
		answers		=>	".striker-answers",
	},
	sys		=>	{
		# 0 == nearly silent
		# 1 == basic messages
		# 2 == details on 'open' calls
		# 3 == variable values
		# 4 == Like 3, but passwords are not surpressed
		debug		=>	3,
		language	=>	"en_CA",
		logger_tag	=>	"striker",
	},
};

get_paths($conf);
read_answers($conf);

# Say hello
welcome($conf);

# Ask the user which language they wish to use
ask_user_to_choose_language($conf);

# Setup the network
ask_user_network_questions($conf);


exit(0);

###############################################################################
# Functions (Some taken from common.lib)                                      #
###############################################################################

# This writes logs entries via the logger logging tool
sub record
{
	my ($conf, $log_level, $message) = @_;
	
	if ($log_level > $conf->{sys}{debug})
	{
		return(0);
	}
	
	open my $file_handle, '-|', "$conf->{executable}{logger}", "-t $conf->{sys}{logger_tag}", "$message" or time_to_die($conf, basic_get_string($conf, 1, "error_0002", {
			shell_call	=>	"$conf->{executable}{tput} cols",
			error		=>	$!,
		}));
	$file_handle->close();
	
	return(0);
}

# Ask the user about how they want their network configured.
sub ask_user_network_questions
{
	my ($conf) = @_;
	
	# Count the number of network interfaces. If 1 or 2, select the 

	return(0);
}

# Presents a list of languages for the user to use.
sub ask_user_to_choose_language
{
	my ($conf) = @_;
	
	print basic_get_string($conf, 1, "message_0002"), "\n"; 
	my $choices = {};
	my $default = "";
	my $i       = 0;
	foreach my $language (sort {$a cmp $b} keys %{$conf->{language}})
	{
		next if not $language;
		next if not $conf->{language}{$language}{name};
		$i++;
		my $say_language = $conf->{language}{$language}{name};
		$choices->{$i} = $language;
		$default = $i if $language eq $conf->{sys}{language};
		print "$i. $say_language [$language]\n";
	}
	print "> [$default] ";
	my $answer_language = <STDIN>;
	chomp($answer_language);
	if ($answer_language)
	{
		$answer_language       = $choices->{$answer_language};
		if ($conf->{sys}{language} ne $answer_language)
		{
			$conf->{sys}{language} = $answer_language;
			welcome($conf);
		}
	}
	$conf->{answers}{language} = $answer_language if $answer_language;
	write_answers($conf);
	my $language = $conf->{sys}{language};
	print basic_get_string($conf, 1, "answer_0001", {language => $conf->{language}{$language}{name}}), "\n";
	
	return(0);
}

# This writes out the questions thus-far answered to save the user from
# re-entering them if the installer exits prematurely.
sub write_answers
{
	my ($conf, $hash_ref, $key, $file_handle, $i) = @_;
	$hash_ref = $conf->{answers} if not defined $hash_ref;
	$key      = "answers"        if not defined $key;
	$i        = 0 if not defined $i;
	
	if (not $file_handle)
	{
		record($conf, 2, basic_get_string($conf, 0, "log_0002", {file => "$conf->{path}{answers}"}));
		open $file_handle, '>', "$conf->{path}{answers}" or time_to_die($conf, basic_get_string($conf, "error_0003", {
				file	=>	"$conf->{path}{answers}",
				error	=>	$!,
			}));
	}
	foreach my $var (sort {$a cmp $b} keys %{$hash_ref})
	{
		if (ref($hash_ref->{$var}) eq "HASH")
		{
			my $new_key = "${key}::${var}";
			$i++;
			write_answers($conf, $hash_ref->{$var}, $new_key, $file_handle, $i);
			$i--;
		}
		else
		{
			print $file_handle "${key}::${var} = $hash_ref->{$var}\n";
		}
	}
	if ($i == 0)
	{
		$file_handle->close();
	}
	
	return(0);
}

# This reads in the 'answers' file, if it exists.
sub read_answers
{
	my ($conf) = @_;
	
	return if not -e $conf->{path}{answers};
	
	record($conf, 2, basic_get_string($conf, 0, "log_0003", {file => "$conf->{path}{answers}"}));
	open my $file_handle, '<', "$conf->{path}{answers}" or time_to_die($conf, basic_get_string($conf, "error_0004", {
			file	=>	"$conf->{path}{answers}",
			error	=>	$!,
		}));
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		if ($line =~ /answers::(.*?) = (.*)/)
		{
			my $var = $1;
			my $val = $2;
			$conf->{answers}{$var} = $val;
		}
	}
	$file_handle->close();
	
	# Push answers that exist over defaults.
	if ($conf->{answers}{language})
	{
		$conf->{sys}{language} = $conf->{answers}{language};
	}
	
	return(0);
}

# This is a dramatically stripped down version of the main get_string() 
# function in the main striker program.
sub basic_get_string
{
	my ($conf, $wrap, $key, $variables) = @_;
	
	my $string   = "";
	my $language = $conf->{sys}{language};
	
	# If this language references another, switch to it.
	if ($conf->{language}{$language}{use_language})
	{
		$language = $conf->{language}{$language}{use_language};
	}
	
	# Empty strings are ok, non-existed key entries are not.
	if (not exists $conf->{language}{$language}{string}{$key})
	{
		# Can't use a nice die here.
		print wrap_string($conf, "[ FATAL ] - I can't get the requested string: [$key] for the language: [$language]. One or both do not exist."), "\n";
		exit(9999);
	}
	$string = $conf->{language}{$language}{string}{$key};
	
	# Inject variables if needed
	if (ref($variables))
	{
		foreach my $variable (keys %{$variables})
		{
			my $value = $variables->{$variable};
			$string =~ s/#!variable!$variable!#/$value/sg;
		}
	}
	
	# Wrap the text if needed.
	if ($wrap)
	{
		$string = wrap_string($conf, $string);
	}
	
	return($string);
}

# This searches the directories in the $ENV{PATH} environment variable looking
# for executables when the specified path is missing or not found.
sub get_paths
{
	my ($conf) = @_;
	
	# NOTE: Don't print anything here unless needed, this is called before
	#       strings are ready to print.
	foreach my $executable (keys %{$conf->{executable}})
	{
		# If the path is already good, return.
		if (($conf->{executable}{$executable}) && (-x $conf->{executable}{$executable}))
		{
			# Path is already good
			return(0)
		}
		
		# Ok, now to look.
		foreach my $path (sort {$a cmp $b} split/,/, $ENV{PATH})
		{
			my $test_path = "$path/$executable";
			if ((-e $test_path) && (-x $test_path))
			{
				# Foud it.
				$conf->{executable}{$executable} = $test_path;
				last;
			}
		}
	}
	
	return(0);
}

# Get the current number of colums for the user's terminal.
sub get_screen_width
{
	my ($conf) = @_;
	
	my $cols = 0;
	record($conf, 2, basic_get_string($conf, 0, "log_0004", {shell_call => "$conf->{executable}{tput} cols"}));
	open my $file_handle, '-|', "$conf->{executable}{tput}", "cols" or time_to_die($conf, basic_get_string($conf, 1, "error_0002", {
			shell_call	=>	"$conf->{executable}{tput} cols",
			error		=>	$!,
		}));
	while (<$file_handle>)
	{
		chomp;
		$cols = $_;
	}
	$file_handle->close();
	
	# Knock back one column to make wrapped lines cleaner.
	$cols-- if $cols > 72;
	
	return($cols);
}

# This exits on error.
sub time_to_die
{
	my ($conf, $error) = @_;
	
	my ($code) = ($error =~ /_(d+)$/);
	$code =~ s/^0//g;
	
	my $prefix   = basic_get_string($conf, 0, "prefix_0001");
	my $message  = basic_get_string($conf, 0, "error_0001");
	my $say_code = basic_get_string($conf, 0, "prefix_0002", {
				error	=>	"code"
			});
	print wrap_string($conf, "$prefix $message"), "\n";
	
	exit ($code);
}

# This wraps the passed screen to the current screen width. Assumes output of
# to text/command line.
sub wrap_string
{
	my ($conf, $string, $variables) = @_;
	
	my $wrap_to = 72;
	if ($variables->{wrap_to})
	{
		$wrap_to = $variables->{wrap_to};
	}
	else
	{
		$wrap_to = get_screen_width($conf);
	}
	
	# No sense proceeding if the string is empty.
	return ($string) if not $string;
	
	# No sense proceeding if there isn't a length to wrap to.
	return ($string) if not $wrap_to;

	# When the string starts with certain borders, try to make it look
	# better by indenting the wrapped portion(s) an appropriate number
	# of spaces and put in a border where it seems needed.
	my $prefix_spaces = "";
	if ( $string =~ /^\[ (.*?) \] - / )
	{
		my $prefix      = "[ $1 ] - ";
		my $wrap_spaces = length($prefix);
		for (1..$wrap_spaces)
		{
			$prefix_spaces .= " ";
		}
	}
	# If the line has spaces at the start, maintain those spaces for
	# wrapped lines.
	elsif ( $string =~/^(\s+)/ )
	{
		# We have some number of white spaces.
		my $prefix     =  $1;
		my $say_prefix =  $prefix;
		$say_prefix    =~ s/\t/\\t/g;
		my $wrap_spaces = length($prefix);
		for (1..$wrap_spaces)
		{
			$prefix_spaces.=" ";
		}
	}
	
	my @words          = split/ /, $string;
	my $wrapped_string = "";
	my $this_line;
	for (my $i=0; $i<@words; $i++)
	{
		# Store the line as it was before in case the next word pushes line line past the 'wrap_to' value.
		my $last_line =  $this_line;
		$this_line    .= $words[$i];
		my $length    =  0;
		if ($this_line)
		{
			$length = length($this_line);
		}
		if ((not $last_line) && ($length >= $wrap_to))
		{
			# This one 'word' is longer than the width of the screen so just pass it along.
			$wrapped_string .= $words[$i]."\n";
			$this_line      =  "";
		}
		elsif (length($this_line) > $wrap_to)
		{
			$last_line      =~ s/\s+$/\n/;
			$wrapped_string .= $last_line;
			$this_line      =  $prefix_spaces.$words[$i]." ";
		}
		else
		{
			$this_line.=" ";
		}
	}
	$wrapped_string .= $this_line;
	$wrapped_string =~ s/\s+$//;
	
	return($string);
}

# This prints the start of the program.
sub welcome
{
	my ($conf) = @_;
	
	#system("clear");
	record($conf, 1, basic_get_string($conf, 0, "log_0001"));
	print "\n";
	print basic_get_string($conf, 1, "message_0001"), "\n\n"; 
	
	return(0);
}

exit 1;